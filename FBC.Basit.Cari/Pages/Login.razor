@using FBC.Basit.Cari.Auth
@attribute [AllowAnonymous]
@inject AuthenticationStateProvider mgr
@inject NavigationManager Navi

@page "/Login"
<div class=row>

    <div class="container px-5 my-5">
        <TextBox @bind-Data="userName" Title="Kullanıcı Adı" />
        <TextBox @bind-Data="password" Title="Parola" IsPassword="true" />
        @if (!trying)
        {
            <div class="d-grid">
                <button class="btn btn-primary btn-lg" id="submitButton" @onclick="TryLogin">Giriş</button>
            </div>
        }
    </div>
    @if (!string.IsNullOrEmpty(loginMessage))
    {
        <div class="alert alert-danger" role="alert">
            @loginMessage
        </div>
    }
</div>

@code {

    string userName;
    string password;
    string loginMessage;
    bool trying = false;

    
    void TryLogin()
    {

        try
        {
            trying = true;
            InvokeAsync(() => StateHasChanged());
            if ((mgr as SessionedAuthenticationStateProvider).Login(userName, password))
            {
                //True parametresi sırf sayfayı refresh etmesi için.
                //TODO Şu an blazor'un kurduğu yapının içinden geçtik. SignalR ağlıyor, webscocket... o da ağlıyordu. 
                //Ancak gelin görün ki bu işe gereğinden fazla zaman ayırdım ve Authorize olayınının bu kısmı araştırmaya fazla vaktim yok.
                //Şimdilik cookie ile bu işi çözdük. Hem böylelikle farklı sekmelerde de uygulamamız sorunsuz çalışıyor. 
                //5 Dk'lık timeout koyduğumuz için (see: FBCAuth.UserSessionManager.IDLE_TIME_LIMIT_SECONDS) websocket bağlantısı devam etse de 
                //auth ölüyor ama olsun. sonra bu işi dengeleriz. Ya çerezden vazgeçeriz ya da WebSocket oturumuna dahil olmanın yolunu buluruz.
                // En kötü çerezden vazgeçer, Blazor'un öngördüğü çalışma şekline teslim olarak tek sekmeden çalıştırmaya teşvik ederiz kullancıyı. 
                Navi.NavigateTo("/", true);
                //Navi.NavigateTo("/");

            }
            else
            {
                loginMessage = "Geçersiz kullanıcı adı veya parola";
            }
        }
        catch (Exception exc)
        {
            loginMessage = "Hata: " + exc.Message;
        }
        finally
        {
            trying = false;
            InvokeAsync(() => StateHasChanged());

        }
    }

}
